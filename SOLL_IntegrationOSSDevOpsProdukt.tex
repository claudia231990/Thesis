Obwohl die Nutzung von OSS Folgen für das gesamte DevOps-Team hat, wird die Entscheidung über die Nutzung von der Rolle des Entwicklers getroffen, wodurch die Prozessanpassungen vorrangig im Bereich der Entwicklung vorgenommen werden müssen. 

Daher wurde für ein besseres Verständnis, ausschließlich die Rolle des Entwicklerteams, mit einem entsprechenden Start und Endpunkt modelliert und die restlichen Rollen nicht weiter behandelt.

\begin{figure}[p]
    \centering
    \includegraphics[angle=90, scale=0.5]{Bilder/SOLL-Prozess.png}
    \caption{Einbindung von OSS in den Softwareentwicklungsprozess basierend auf dem HAF-Projekt}s
\end{figure}

Da zu dem Zeitpunkt der Nutzung von OSS die Projektstruktur bereits besteht und das Product Backlog ebenfalls erstellt wurde, bildet den Anfang des DevOps-Prozesses nun die Anpassung des priorisierten Product Backlogs.

Nachdem das Sprint Planning Meeting durchgeführt worden ist, kann die Iteration gestartet werden. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{Bilder/SOLL-Prozess_first Part.png}
    \caption{Erster Teil des Softwareentwicklungsprozess im SOLL-Zustand basierend auf dem HAF-Projekt}
\end{figure}

Wie auch bei dem IST-Zustand muss sich zunächst die Frage gestellt werden, ob Codeänderungen durchgeführt werden müssen, unabhängig ob es auf Änderungen eines vorhandenen Codes oder auf eine Neuimplentierung bezieht. 

Sollten Codeänderungen vorgenommen werden, wird der Implementierungsvorgang für das Backlog Item gestartet. 

Ab diesem Zeitpunkt setzt die Nutzung von OSS die Prozessänderungen in Gang.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{Bilder/SOLL-Prozess_second Part.png}
    \caption{Zweiter Teil des Softwareentwicklungsprozess im SOLL-Zustand basierend auf dem HAF-Projekt}
\end{figure}

Um präventiv maßgebliche Konsequenzen durch die Nutzung von OSS zu vermeiden, sollten sich die betreffenden Entwickler die Frage stellen, ob tatsächliche eine neue Software oder Softwarekomponete in das Projekt eingebunden werden muss. 

Falls dies der Fall ist, muss zunächst ein initaler OSS-Check durchgeführt werden. 

Dieser dient dazu, das Lizenzmodell der verwendeten OSS-Komponete zu überprüfen und diese mit den 'ungefährlichen' Lizenzmodellen zu vergleichen. 

Dies hat zum Vorteil, dass der Entwickler bereits vor einer langen Implementierung eine Aussage darüber treffen kann, ob sich aus Sicht der Lizenzmodelle eine Verwendung eignet oder ob ein Lizenzmodell vorliegt, welches zumindest ein beschränktes Copyleft aufweist. 

Sollte die verwendete OSS-Komponete ein derartiges Lizenzmodell aufweisen, hat der Entwickler ausreichend Zeit, nach eine 'ungefährlichen' Alternative zu suchen.  

Wird die OSS-Kompoente letztlich verwendet, wird ein Pull-Request für ein Commit durchgeführt. 

An diesem Punkt befindet sich der Entwickler ebenfalls, wenn keine neue OSS genutzt wird. 

Anschließend hierzu werden wie im gängigen Prozess, Unit-Tests und Codeanalysen durchgeführt und diese  vom Reviewer bestätigen lassen.

Gleichzeitig zu diesen Schritten muss eine neue Anpassung des Prozesses im Hinblick auf die Verwendung von OSS als ein automatisierten OSS-Check durchgeführt werden.

Während bei einer Verwendung von neuer OSS die Lizenzmodelle zeitnah überprüft werden können, kann es Fälle geben, in denen Versionen einer bereits implementierten OSS-Komponete geändert werden und daraus eine Verschiebung der betreffenden Lizenzmodelle stattfinden kann. 

Dies kann dazu führen, dass OSS-Komponeten ein starkes Copyleft aufweisen, obwohl diese mit einem schwachen oder keinen Copyleft implementiert worden sind. 

Ferner würde bei einer gängigen Entwicklung diese Situation nicht auffallen und bietet daher ein großes Risiko. 

Durch einen automatisierten OSS-Check können die Lizenzmodelle der verwendeten OSS-Komponeten anhand ihrer Versionen dargestellt werden. 

Damit erhalten alle Entwickler einen genauen Überblick über die verwendeten OSS-Komponeten und deren akutellen Lizenzstatus. 

Zu beachten ist dabei, dass der automatisierte OSS-Check nach jedem Commit ausgeführt werden muss, damit die Entwickler genug Zeit haben, nach einer Lösung für eine mögliche Lizenzproblematik zu suchen.

Durch die zeitnahe Übermittlung der notwendigen Informationen wird die Transparenz zwischen den DevOps-Mitgliedern sichergestellt. 

Die Automatisierung des OSS-Checks entspricht sowohl der Kultur als auch den Methoden nach den DevOps-Prinzipien.

Sollte die OSS-Komponete kein schwieriges Copyleft aufweisen, wird dieser Zustand zunächst vom Reviewer bestätigt und kann dann als Backlog Item erfolgreich implementiert und auf das Master Branch gemergt werden. 

Falls dies nicht der Fall ist, muss die OSS-Thematik zunächst geklärt werden.

Sollte die entstandene Problematik nicht behoben werden, so muss der Projektleiter informiert werden und die Dev-Beteiligung endet zunächst an dieser Stelle. 

Kann die OSS-Thematik gelöst werden, muss diese zunächst überarbeitet werden. 

Dies reicht von einem Rückgang auf eine alte Version, wobei an dieser Stelle die gesamte Funktionalität gewährleistet werden muss, bis zur Verwerfung der entsprechenden Kompoente durch den Entwickler. 

Dieser Aufgabenbereich kann mehrere Unteraufgaben aufweisen und die Lösung ist demnach spezifisch auf die Komponete und deren Entwicklung ausgelegt. 

Nach der Überarbeitung erfolgt eine erneute Bestätigung durch einen Reviewer, zum Ziel, die Kompoente erfolgreich auf den Master Branch zu mergen. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{Bilder/SOLL-Prozess_third Part.png}
    \caption{Dritter Teil des Softwareentwicklungsprozess im SOLL-Zustand basierend auf dem HAF-Projekt}
\end{figure}

Sobald das Release auf seine Vollständigkeit und Richtigkeit überprüft worden ist, wird zur erneuten Kontrolle der Lizenzmodelle ein Report erstellt. 

Dieser dient als eine Nachdokumentation, einerseits falls sich unbeabsichtigt Änderungen ergeben haben, die bisher nicht gesehen wurden und andererseits zur Vorlage für den Stakeholder, um den Status der verwendeten OSS-Komponeten transparent zu präsentieren. 

Die Iteration endet mit der Vorstellung der Ergebnisse im Review. 

Basierend auf der Nachdokumentation muss anschließend analysiert werden, ob Auffälligkeiten innerhalb der Lizenzthematik festgestellt wurden.  

Ergeben sich tatsächlich Auffälligkeiten, müssen diese zunächst definiert werden und werden in den Product Backlog übermittelt. 

Müssen keine Veränderungen vorgenommen werden, wird das Release bereitgestellt. 

Genau wie bei dem gängigen Softwareentwicklungsprozess im IST-Zustand, endet dieser Prozess ebenfalls mit einem leeren Product Backlog.  

















